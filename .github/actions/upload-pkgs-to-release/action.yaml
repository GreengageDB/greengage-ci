name: Upload Packages to GitHub Release
description: "Create or update a GitHub release and upload packages with fixed names"

inputs:
  artifact_name:
    description: 'Artifact name for download'
    required: false
    default: 'Packages'
  package_name:
    description: 'Base package name, defaults to repository name'
    required: false
    default: ''
  release_name:
    description: 'Target release name, defaults to current tag'
    required: false
    default: ''
  version:
    description: 'Version string to append to package name'
    required: false
    default: ''
  extensions:
    description: 'Space-separated list of package file extensions'
    required: false
    default: 'deb ddeb rpm'
  create_force:
    description: 'Force create the release if not exists, defaults false'
    required: false
    default: ''
  clobber:
    description: 'Overwrite existing assets if they exist. Defaults to false (skip if exists)'
    required: false
    default: ''
  ci_wait_timeout:
    description: 'Timeout in seconds to wait for CI workflow'
    required: false
    default: '14400'  # 4 hours
  ci_poll_interval:
    description: 'Poll interval in seconds to check CI workflow status'
    required: false
    default: '60'  # 1 minute
  workflow_for_waiting:
    description: 'Packages generation workflow name for waiting'
    required: false
    default: 'Greengage CI'

runs:
  using: "composite"
  steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Debug ref context RESTORE ACTION
      shell: bash
      run: |
        echo "Current ref: ${{ github.ref }}"
        echo "Current ref_name: ${{ github.ref_name }}"
        echo "Current sha: ${{ github.sha }}"
        echo "Event name: ${{ github.event_name }}"

    - name: Wait for package generation workflow completion
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        MAX_WAIT_SECONDS: ${{ inputs.ci_wait_timeout }}
        POLL_INTERVAL: ${{ inputs.ci_poll_interval }}
        WORKFLOW: ${{ inputs.workflow_for_waiting }}
      run: |
        start_time=$(date +%s)

        while true; do
          elapsed=$(($(date +%s) - start_time))
          remaining=$((MAX_WAIT_SECONDS - elapsed))
          
          if [ $remaining -le 0 ]; then
            echo "ERROR: Timeout waiting for CI workflow (waited ${MAX_WAIT_SECONDS}s)"
            exit 1
          fi

          result=$(gh run list --workflow "$WORKFLOW" --limit 100 \
            --json conclusion,headSha,event,headBranch,url,status \
            --jq '
              map(select(
                .headSha == "'"${{ github.sha }}"'" and 
                .event == "push" and 
                .headBranch == "'"${{ github.event.release.tag_name }}"'"
              )) |
              .[0]
            ')

          if [ -z "$result" ] || [ "$result" = "null" ]; then
            echo "CI workflow not found yet. Waiting... (${remaining}s remaining)"
            sleep $POLL_INTERVAL
            continue
          fi

          status=$(echo "$result" | jq -r '.status // empty')
          conclusion=$(echo "$result" | jq -r '.conclusion // empty')
          run_url=$(echo "$result" | jq -r '.url')

          if [ "$status" = "completed" ] && [ "$conclusion" = "success" ]; then
            echo "CI_WORKFLOW_URL=$run_url" >> $GITHUB_ENV
            break
          fi

          if [ "$status" = "in_progress" ] || [ "$status" = "queued" ] || [ "$status" = "waiting" ] || [ "$status" = "pending" ]; then
            echo "Current status: '$status'. Continue waiting... (${remaining}s remaining)"
            sleep $POLL_INTERVAL
            continue
          fi

          echo "ERROR: CI workflow failed or was skipped. Failed run url: '$run_url'"
          jq <<< "$result"
          exit 1
        done

    - name: Restore Package artifacts from cache
      uses: actions/cache/restore@v4
      id: cache-restore
      with:
        path: ${{ inputs.artifact_name }}
        key:  ${{ inputs.artifact_name }}-${{ github.sha }}

    - name: Handle cache miss or restore failure
      if: steps.cache-restore.outputs.cache-hit != 'true'
      shell: bash
      run: |
        echo "ERROR: Cache missed but last build succeeded. No artifacts found for tag: '${{ github.event.release.tag_name }}'"
        echo "Please go to ${CI_WORKFLOW_URL:-the CI workflow run} and click 'Re-run all jobs' to rebuild cache"
        exit 1

    - name: List downloaded files
      shell: bash
      run: find "${{ inputs.artifact_name }}" -type f

    - name: Create release if not exists
      if: inputs.create_force != ''
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        RELEASE_NAME: ${{ inputs.release_name }}
        PACKAGE_NAME: ${{ inputs.package_name }}
      run: |
        PACKAGE_NAME=${PACKAGE_NAME:-${GITHUB_REPOSITORY#*/}}
        RELEASE_NAME=${RELEASE_NAME:-${GITHUB_REF#refs/tags/}}

        for var in PACKAGE_NAME RELEASE_NAME ; do
          if [ -z "${!var}" ] ; then
            echo "Can't determine $var"
            exit 1
          fi
        done

        if ! gh release view "$RELEASE_NAME" > /dev/null 2>&1; then
          gh release create "$RELEASE_NAME" \
            --title "Release $RELEASE_NAME" \
            --notes "$PACKAGE_NAME $RELEASE_NAME
        Built from commit: $GITHUB_SHA
        Workflow run: $GITHUB_RUN_NUMBER"
        else
          echo "Release $RELEASE_NAME already exists, skipping creation."
        fi

    - name: Check release exists
      shell: bash
      id: check_release
      env:
        GH_TOKEN: ${{ github.token }}
        RELEASE_NAME: ${{ inputs.release_name }}
      run: |
        RELEASE_NAME="${RELEASE_NAME:-${GITHUB_REF#refs/tags/}}"
        if gh release view "$RELEASE_NAME" > /dev/null 2>&1; then
          echo "Release '$RELEASE_NAME' exists, proceeding with upload"
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "Release '$RELEASE_NAME' not found, skipping upload"
        fi

    - name: Move and upload packages
      if: steps.check_release.outputs.exists == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        RELEASE_NAME: ${{ inputs.release_name }}
        PACKAGE_NAME: ${{ inputs.package_name }}
      run: |
        PACKAGE_NAME=${PACKAGE_NAME:-${GITHUB_REPOSITORY#*/}}
        RELEASE_NAME=${RELEASE_NAME:-${GITHUB_REF#refs/tags/}}

        for var in PACKAGE_NAME RELEASE_NAME ; do
          if [ -z "${!var}" ] ; then
            echo "Can't determine $var"
            exit 1
          fi
        done

        shopt -s nullglob
        
        for ext in ${{ inputs.extensions }}; do
          files=("${{ inputs.artifact_name }}"/*.$ext)
          if [ ${#files[@]} -ne 1 ]; then
            echo "Expected exactly one *.$ext file, found ${#files[@]}"
            exit 1
          fi

          target="${{ inputs.artifact_name }}/${PACKAGE_NAME}${{ inputs.version }}.$ext"
          mv -f "${files[0]}" "$target"
          echo "Uploading $target"
          gh release upload "$RELEASE_NAME" "$target" ${{ inputs.clobber == 'true' && '--clobber' || '' }} || not_uploaded=${not_uploaded:+$not_uploaded, }$ext
        done
        if [ -n "$not_uploaded" ] ; then
          echo "The following extension(s) are not uploaded: $not_uploaded"
          exit 1
        fi
