# Environment variables
env:
  DOCKER_HOST: "tcp://localhost:2375"
  LIBGUESTFS_DEBUG: 1
  LIBGUESTFS_TRACE: 1

# Trigger for reusable workflow
on:
  workflow_call:
    inputs:
      version:
        description: 'Greengage version (e.g., 6 or 7)'
        required: true
        type: string
      target_os:
        description: 'Target OS for build (e.g., ubuntu, centos, rockylinux)'
        required: true
        type: string
      target_os_version:
        description: 'Target OS version (e.g., 22, 7, 8)'
        required: false
        type: string
        default: ''
      python3:
        description: 'Python3 build argument (ignored)'
        required: false
        type: string
        default: ''
    secrets:
      ghcr_token:
        description: 'GitHub token for GHCR access'
        required: true

jobs:
  optimizer:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        optimizer: ${{ fromJson(inputs.version == '6' && '["postgres"]' || '["orca", "postgres"]') }}
    permissions:
      contents: read  # Explicit for default behavior
      packages: read  # Explicit for GHCR access clarity
      actions: write  # Required for cache and artifact upload

    steps:
      # Checkout repository with specified ref or default
      - name: Setup QEMU
        run: |
          set -eux
          sudo apt update
          sudo DEBIAN_FRONTEND=noninteractive apt install -y qemu-kvm qemu-utils cloud-image-utils libguestfs-tools

      - uses: actions/cache@v4
        id: cache-qemu
        with:
          path: ~/.cache/qemu
          key: ubuntu-22.04-image

      - name: Download Ubuntu cloud image
        if: steps.cache-qemu.outputs.cache-hit != 'true'
        run: |
          set -eux
          mkdir -p ~/.cache/qemu
          wget -q -O ~/.cache/qemu/ubuntu-22.04.img \
            https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img

      - name: Create VM disk and cloud-init config
        run: |
          set -eux
          mkdir -p logs vm-home/logs vm-work
          cd vm-work

          function dbg {
            pwd
            ls -lah
          }

          trap dbg EXIT ERR

          # Extract kernel from cloud image for usin as external
          sudo virt-get-kernel -v -x --add ~/.cache/qemu/ubuntu-22.04.img
          sudo chmod -R a+rwX ./

          # Make clear links to kernel files
          for f in initrd vmlinuz ; do
            find . -maxdepth 1 -type f -name "$f*" -exec ln -sf {} $f \;
          done

          # Copy base image and resize
          cp ~/.cache/qemu/ubuntu-22.04.img vm-disk.qcow2
          qemu-img resize vm-disk.qcow2 20G
          
          # Create cloud-init user-data
          cat > user-data <<EOF1
          #cloud-config
          users:
            - name: gpadmin
              sudo: ALL=(ALL) NOPASSWD:ALL
              shell: /bin/bash
              uid: $UID

          write_files:
            - path: /etc/fstab
              append: true
              content: |
                hostshare /home/gpadmin 9p trans=virtio,version=9p2000.L,rw,_netdev 0 0

          runcmd:
            - mount -t 9p -o trans=virtio,version=9p2000.L,rw hostshare /home/gpadmin
            - mkdir -p /home/gpadmin/logs
            - curl -fsSL https://get.docker.com -o get-docker.sh
            - sh get-docker.sh --version 20.10
            - systemctl disable --now docker.socket  # ← Отключаем socket
            - |
              cat > /etc/docker/daemon.json <<'EOF2'
              {
                "hosts": ["unix:///var/run/docker.sock", "tcp://127.0.0.1:2375"]
              }
              EOF2
            - systemctl enable --now docker  # ← Включаем и запускаем сервис!
            - echo "Docker status:" > /home/gpadmin/logs/docker-debug.log
            - systemctl status docker >> /home/gpadmin/logs/docker-debug.log 2>&1
            - echo "Docker journal:" >> /home/gpadmin/logs/docker-debug.log
            - journalctl -u docker.service -n 20 >> /home/gpadmin/logs/docker-debug.log 2>&1
            - echo "Docker info attempt:" >> /home/gpadmin/logs/docker-debug.log
            - docker info >> /home/gpadmin/logs/docker-debug.log 2>&1 || echo "docker info failed" >> /home/gpadmin/logs/docker-debug.log
          EOF1

          # Create meta-data
          echo "instance-id: github-actions-vm" > meta-data
          
          dbg

          # Create cloud-init ISO
          cloud-localds seed.img user-data meta-data

      - name: Start QEMU VM with shared volume and cgroups v1
        run: |
          set -eux
          cd vm-work

          # Start QEMU VM with kernel parameters for cgroups v1
          sudo qemu-system-x86_64 \
            -machine type=pc,accel=kvm \
            -cpu host \
            -smp 4 \
            -m 8192 \
            -drive file=vm-disk.qcow2,format=qcow2,if=virtio \
            -drive file=seed.img,format=raw,if=virtio \
            -netdev user,id=net0,hostfwd=tcp::2375-:2375 \
            -device virtio-net-pci,netdev=net0 \
            -fsdev local,security_model=passthrough,id=fsdev0,path=../vm-home \
            -device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=hostshare \
            -kernel vmlinuz \
            -initrd initrd \
            -append "root=/dev/vda1 ro console=tty1 console=ttyS0 systemd.unified_cgroup_hierarchy=0" \
            -display none \
            -daemonize \
            -pidfile qemu.pid \
            -serial file:../vm-home/logs/qemu-serial.log \
            -D ../vm-home/logs/qemu-debug.log

      - name: Wait for VM to boot and Docker to be available
        run: |
          echo "Waiting for VM to boot and Docker to start..."
          timeout=300
          attempt=1
          
          # Wait for port to open first
          while [ $timeout -gt 0 ]; do
            echo "Attempt $attempt: Checking port 2375..."
            
            if nc -z -w 2 localhost 2375; then
              echo "✅ Port 2375 is open"
              break
            else
              echo "⏳ Port not ready yet"
              sleep 5
              timeout=$((timeout - 5))
              attempt=$((attempt + 1))
            fi
          done
          
          if [ $timeout -le 0 ]; then
            echo "❌ Port 2375 failed to open within timeout"
            exit 1
          fi
          
          # Reset counters for Docker check
          timeout=180
          attempt=1
          
          # Wait for Docker to be fully ready
          while [ $timeout -gt 0 ]; do
            echo "Attempt $attempt: Testing Docker connection..."
            
            if docker -H tcp://localhost:2375 info >/dev/null 2>&1; then
              echo "✅ Docker is fully operational!"
              docker -H tcp://localhost:2375 info | grep -E "(Server Version|Containers|Images)"
              break
            else
              echo "⏳ Docker starting up..."
              sleep 10
              timeout=$((timeout - 10))
              attempt=$((attempt + 1))
            fi
          done
          
          if [ $timeout -le 0 ]; then
            echo "❌ Docker failed to start within timeout"
            echo "Last check:"
            docker -H tcp://localhost:2375 info 2>&1 | head -20 || true
            exit 1
          fi
          
          # Final stabilization wait
          echo "Waiting 15 seconds for Docker to stabilize completely..."
          sleep 15

      - name: DEBUG Quick Docker debug
        if: always()
        run: |
          echo "Testing raw TCP connection..."
          timeout 5 bash -c 'echo "GET /info HTTP/1.0\r\n" | nc -w 2 localhost 2375' || true
          
          echo "Checking if port is actually open..."
          netstat -tln | grep 2375 || true
          
          echo "Trying simple curl..."
          curl -s -o /dev/null -w "%{http_code}" http://localhost:2375/info || true
          echo ""

      - name: DEBUG Normalize permissions
        if: always()
        run: |
          sudo chmod -R a+rwX vm-home/ vm-work/
          ls -lah vm-home/* vm-work/* || true

      - name: Check Docker debug info
        if: always()
        run: |
          if [ -f vm-home/logs/docker-debug.log ]; then
            echo "=== DOCKER DEBUG LOG ==="
            cat vm-home/logs/docker-debug.log
            echo "========================"
          else
            echo "Debug log not found - VM may not have booted properly"
          fi

      # Restore SHA image from cache
      - name: Restore SHA image from cache
        uses: actions/cache/restore@v4
        with:
          path: ggdb${{ inputs.version }}_${{ inputs.target_os }}${{ inputs.target_os_version }}_${{ github.sha }}.tar
          key: ggdb${{ inputs.version }}_${{ inputs.target_os }}${{ inputs.target_os_version }}_${{ github.sha }}

      # Move Docker image to shared directory
      - name: Move Docker image to shared directory
        run: mv ggdb${{ inputs.version }}_${{ inputs.target_os }}${{ inputs.target_os_version }}_${{ github.sha }}.tar vm-home/

      # Load image directly from shared volume
      - name: Load SHA image in VM from shared volume
        run: |
          # Wait a bit for shared volume to be fully mounted
          sleep 10

          # Load Docker image from shared volume
          docker load < /home/gpadmin/ggdb${{ inputs.version }}_${{ inputs.target_os }}${{ inputs.target_os_version }}_${{ github.sha }}.tar

          # Clean up the tar file from shared volume
          rm vm-home/ggdb${{ inputs.version }}_${{ inputs.target_os }}${{ inputs.target_os_version }}_${{ github.sha }}.tar

      - name: Resource groups test ${{ github.job }} ${{ matrix.optimizer }}
        env:
          IMAGE: ghcr.io/${{ github.repository }}/ggdb${{ inputs.version }}_${{ inputs.target_os }}${{ inputs.target_os_version }}:${{ github.sha }}
          TEST_OS: ${{ inputs.target_os }}
          STATEMENT_MEM: ${{ inputs.version == '7' && '125MB' || '250MB' }}
          OPTIMIZER: ${{ matrix.optimizer == 'orca' && 'on' || 'off' }}
        run: |
          export IMAGE=${IMAGE,,}
          # Get test script from image NOT from repo
          docker create --name temp-container $IMAGE
          docker cp temp-container:/home/gpadmin/gpdb_src/ci/scripts/run_resgroup_test.bash ./run_resgroup_test.bash
          docker rm temp-container
          ./run_resgroup_test.bash

      - name: Upload resgroup ${{ github.job }} ${{ matrix.optimizer }} artifacts
        if: always()  # Run even if previous step fails
        uses: actions/upload-artifact@v4
        with:
          name: resgroup_ggdb${{ inputs.version }}_${{ inputs.target_os }}${{ inputs.target_os_version }}_${{ github.job }}_${{ matrix.optimizer }}
          path: vm-home/logs
          retention-days: 7
          if-no-files-found: warn  # Warning if no artifacts are found

      - name: Cleanup VM
        if: always()
        run: |
          if [ -d vm-work ]; then
            cd vm-work
            if [ -f qemu.pid ]; then
              # Read PID safely
              pid=$(cat qemu.pid) && {
                # Graceful shutdown first
                sudo kill $pid 2>/dev/null || true
                sleep 3
                # Check if process still exists with the same PID and name
                if ps -p $pid >/dev/null && [ "$(ps -p $pid -o comm=)" = "qemu-system-x86" ]; then
                  echo "Force killing QEMU process $pid"
                  sudo kill -9 $pid 2>/dev/null || true
                fi
              }
              # Cleanup PID file
              rm -f qemu.pid
            fi
            cd ..
          fi
          # Additional cleanup
          sudo pkill -f "qemu-system-x86_64" || true
