# Environment variables
# env:
#   LIBGUESTFS_DEBUG: 1
#   LIBGUESTFS_TRACE: 1

# Trigger for reusable workflow
on:
  workflow_call:
    inputs:
      version:
        description: 'Greengage version (e.g., 6 or 7)'
        required: true
        type: string
      target_os:
        description: 'Target OS for build (e.g., ubuntu, centos, rockylinux)'
        required: true
        type: string
      target_os_version:
        description: 'Target OS version (e.g., 22, 7, 8)'
        required: false
        type: string
        default: ''
      python3:
        description: 'Python3 build argument (ignored)'
        required: false
        type: string
        default: ''
    secrets:
      ghcr_token:
        description: 'GitHub token for GHCR access'
        required: true

jobs:
  optimizer:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        optimizer: ${{ fromJson(inputs.version == '6' && '["postgres"]' || '["orca", "postgres"]') }}
    permissions:
      contents: read  # Explicit for default behavior
      packages: read  # Explicit for GHCR access clarity
      actions: write  # Required for cache and artifact upload
    env:
      IMAGE_NAME: ggdb${{ inputs.version }}_${{ inputs.target_os }}${{ inputs.target_os_version }}
      IMAGE_REPO: ghcr.io/${{ github.repository }}
      IMAGE_SHA: ${{ github.sha }}
      TEST_OS: ${{ inputs.target_os }}
      STATEMENT_MEM: ${{ inputs.version == '7' && '125MB' || '250MB' }}

    steps:
      - name: Setup QEMU
        run: |
          set -eux
          sudo apt update
          sudo DEBIAN_FRONTEND=noninteractive apt install -y qemu-kvm qemu-utils cloud-image-utils libguestfs-tools

      - name: Try to restore Ubuntu cloud image from cache
        uses: actions/cache@v4
        id: cache-qemu
        with:
          path: ubuntu-22.04.img
          key:  ubuntu-22.04-image

      - name: Download Ubuntu cloud image
        if: steps.cache-qemu.outputs.cache-hit != 'true'
        run: |
          set -eux
          wget -q -O ubuntu-22.04.img \
            https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img

      - name: Restore SHA image from cache
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.IMAGE_NAME }}_${{ env.IMAGE_SHA }}.tar
          key:  ${{ env.IMAGE_NAME }}_${{ env.IMAGE_SHA }}

      - name: Create cloud-init script
        env:
          OPTIMIZER:  ${{ matrix.optimizer == 'orca' && 'on' || 'off' }}
          IMAGE_FILE: ${{ env.IMAGE_NAME }}_${{ env.IMAGE_SHA }}.tar
        run: |
          set -eux
          mkdir -p vm-home

          cat > vm-home/cloud-init <<EOF0
          # cloud-init setup script
          set -e

          export TEST_OS=${TEST_OS}
          export OPTIMIZER=${OPTIMIZER}
          export STATEMENT_MEM=${STATEMENT_MEM}
          export IMAGE=${IMAGE_REPO,,}/${IMAGE_NAME}:${IMAGE_SHA}

          curl -fsSL https://get.docker.com -o get-docker.sh
          sh get-docker.sh --version 20.10
          systemctl enable --now docker

          cd /home/gpadmin
          mkdir -p logs

          # Debug info
          echo ">>> \$(date) Debug cloud-init log" | tee /home/gpadmin/logs/cloud-init-debug.log
          ls -lah /home/gpadmin | tee -a /home/gpadmin/logs/cloud-init-debug.log
          echo "Docker status:" | tee -a /home/gpadmin/logs/cloud-init-debug.log
          systemctl status docker.service | tee -a /home/gpadmin/logs/cloud-init-debug.log 2>&1
          echo "Docker journal:" | tee -a /home/gpadmin/logs/cloud-init-debug.log
          journalctl -xeu docker.service | tee -a /home/gpadmin/logs/cloud-init-debug.log 2>&1

          ls -lah logs | tee -a /home/gpadmin/logs/cloud-init-debug.log 2>&1

          docker load < ${IMAGE_FILE}
          rm ${IMAGE_FILE}

          # Extract test script from Image instaed of GIT
          docker create --name temp-container \$IMAGE
          docker cp temp-container:/home/gpadmin/gpdb_src/ci/scripts/run_resgroup_test.bash ./run_resgroup_test.bash
          docker rm temp-container

          source run_resgroup_test.bash
          echo ">>> \$(date) Debug cloud-init EXIT_CODE=\$EXIT_CODE after run_resgroup_test.bash" | tee /home/gpadmin/logs/cloud-init-debug.log
          EOF0

      - name: Create VM disk and cloud-init config
        env:
          OPTIMIZER:  ${{ matrix.optimizer == 'orca' && 'on' || 'off' }}
          IMAGE_FILE: ${{ env.IMAGE_NAME }}_${{ env.IMAGE_SHA }}.tar
        run: |
          set -eux
          mkdir -p vm-work

          # Move image to VM Home folder
          mv ${IMAGE_FILE} vm-home/

          # Copy virtual disk to VM Work folder
          cp ubuntu-22.04.img vm-work/vm-disk.qcow2

          cd vm-work

          # Extract kernel from cloud image for usin as external
          sudo virt-get-kernel --add vm-disk.qcow2
          sudo chmod -R a+rwX .

          # Make clear links to kernel files
          for f in initrd vmlinuz ; do
            find . -maxdepth 1 -type f -name "$f*" -exec ln -sf {} $f \;
          done

          qemu-img resize vm-disk.qcow2 20G

          # Create cloud-init user-data
          cat > user-data <<EOF1
          #cloud-config
          users:
            - name: gpadmin
              sudo: ALL=(ALL) NOPASSWD:ALL
              shell: /bin/bash
              uid: $UID
          runcmd:
            - mount -t 9p -o trans=virtio,version=9p2000.L,rw hostshare /home/gpadmin
            - bash /home/gpadmin/cloud-init
            - echo ">>>>> DEBUG cloud-init -- ls -la /home/gpadmin" ; ls -la /home/gpadmin
            - echo ">>>>> DEBUG cloud-init -- ls -la /home/gpadmin/logs" ; ls -la /home/gpadmin/logs
            - echo ">>>>> DEBUG cloud-init -- cat /home/gpadmin/logs/.exit_code after exit cloud-init" ; cat /home/gpadmin/logs/.exit_code
            - echo ">>>>> DEBUG cloud-init -- cat /home/gpadmin/logs/.exit_code after echo EXIT_CODE" ; cat /home/gpadmin/logs/.exit_code
            - shutdown -h now
          EOF1

          # Create meta-data
          echo "instance-id: github-actions-vm" > meta-data
          
          # Create cloud-init ISO
          cloud-localds seed.img user-data meta-data

      - name: Start QEMU VM with shared volume and cgroups v1
        run: |
          set -eux
          rm -f vm-home/exit_code
          cd vm-work
          sudo qemu-system-x86_64 \
            -machine type=pc,accel=kvm \
            -cpu host \
            -smp 4 \
            -m 8192 \
            -pidfile qemu.pid \
            -drive file=vm-disk.qcow2,format=qcow2,if=virtio \
            -drive file=seed.img,format=raw,if=virtio \
            -netdev user,id=net0 \
            -device virtio-net-pci,netdev=net0 \
            -fsdev local,security_model=passthrough,id=fsdev0,path=../vm-home \
            -device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=hostshare \
            -kernel vmlinuz \
            -initrd initrd \
            -append "root=/dev/vda1 ro console=tty1 console=ttyS0 systemd.unified_cgroup_hierarchy=0" \
            -display none \
            -serial stdio
          cd -
          ls -la ./
          ls -la ./* || true
          exit_code=$(cat vm-home/logs/.exit_code)
          echo ">>> 'exit_code' on Runner '$exit_code'"
          exit $exit_code

      - name: Normalize permissions
        if: always()
        run: |
          sudo chmod -R a+rwX vm-home/ vm-work/
          ls -lah vm-home/* vm-work/* || true

      - name: Upload resgroup ${{ github.job }} ${{ matrix.optimizer }} artifacts
        if: always()  # Run even if previous step fails
        uses: actions/upload-artifact@v4
        with:
          name: resgroup_${{ env.IMAGE_NAME }}_${{ github.job }}_${{ matrix.optimizer }}
          path: vm-home/logs
          retention-days: 7
          if-no-files-found: warn  # Warning if no artifacts are found

      - name: Cleanup VM
        if: always()
        run: |
          set -e
          PIDFILE=vm-work/qemu.pid
          if [ -f $PIDFILE ]; then
            # Read PID safely
            pid=$(cat $PIDFILE) && {
              # Graceful shutdown first
              sudo kill $pid 2>/dev/null || true
              sleep 3
              # Check if process still exists with the same PID and name
              if ps -p $pid >/dev/null && [ "$(ps -p $pid -o comm=)" = "qemu-system-x86" ]; then
                echo "Force killing QEMU process $pid"
                sudo kill -9 $pid 2>/dev/null || true
              fi
            }
            # Cleanup PID file
            rm -f $PIDFILE
          fi
          # Additional cleanup
          sudo pkill -f "qemu-system-x86_64" || true
